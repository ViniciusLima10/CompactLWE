

# This file was *autogenerated* from the file ataque.sage
from sage.all_cmdline import *   # import sage library

_sage_const_2 = Integer(2); _sage_const_32 = Integer(32); _sage_const_16 = Integer(16); _sage_const_22 = Integer(22); _sage_const_86 = Integer(86); _sage_const_20 = Integer(20); _sage_const_21 = Integer(21); _sage_const_1 = Integer(1); _sage_const_0 = Integer(0); _sage_const_100 = Integer(100); _sage_const_0p0 = RealNumber('0.0')
from sage.all import *

# Compact-LWE parameters
q = _sage_const_2 **_sage_const_32 
t = _sage_const_2 **_sage_const_16 
m = _sage_const_22 
w = _sage_const_86 
n = _sage_const_20 
b = _sage_const_21 
R = Integers(q)

# Key generation function
def keygen():
    s = vector(R, [R.random_element() for _ in range(n)])
    r = randint(_sage_const_2 , ceil(q / w / t) - _sage_const_1 )
    p = _sage_const_0 
    while gcd(p, q) > _sage_const_1 :
        p = randint(t, ceil(q / r / w) - _sage_const_1 )
    sk = _sage_const_0 
    while gcd(sk, q) > _sage_const_1  or gcd(sk, p) > _sage_const_1 :
        sk = randint(_sage_const_1 , ceil((q - w * r * p) / (t - _sage_const_1 )) - _sage_const_1 )
    return s, r, p, sk

# Sample generation function
def samplegen(s, r, p, sk):
    A = random_matrix(ZZ, m, n, x=_sage_const_0 , y=b)
    k = R(p) / R(sk)
    e = vector(R, [randint(_sage_const_0 , r - _sage_const_1 ) for _ in range(m)])
    v = A * s + k * e
    return A, v.change_ring(ZZ), e

# Encryption function
def encrypt(A, v, mu):
    a = vector(R, n)
    x = R(mu)
    for _ in range(w):
        j = randint(_sage_const_0 , m - _sage_const_1 )
        a += A[j]
        x -= v[j]
    return a.change_ring(ZZ), x.lift()

# Subset sum decryption attack function
def subsetsumdecrypt(A, v, a, x):
    kappa = q
    L = block_matrix(ZZ, [
        [_sage_const_1 , _sage_const_0 , kappa * a.row(), x],
        [_sage_const_0 , t * identity_matrix(m), -kappa * A, v.column()],
        [_sage_const_0 , _sage_const_0 , _sage_const_0 , q]
    ])
    L = L.LLL()
    
    # Index of the first non-zero entry in the first column of L
    idx = next((i for i, x in enumerate(L.column(_sage_const_0 ).list()) if x != _sage_const_0 ))
    g = gcd(L[:idx, -_sage_const_1 ].list())
    cand = L[idx, -_sage_const_1 ] // L[idx, _sage_const_0 ]
    if g > t:
        cand = cand % g
    return L, cand

# Test function for the decryption attack
def testsubsetsumdecrypt(trials=_sage_const_100 , pairs=_sage_const_1 ):
    succ = _sage_const_0 
    tottime = _sage_const_0p0 
    for npair in range(pairs):
        s, r, p, sk = keygen()
        A, v, e = samplegen(s, r, p, sk)
        succnow = _sage_const_0 
        for _ in range(trials):
            mu = randint(_sage_const_1 , t - _sage_const_1 )
            a, x = encrypt(A, v, mu)
            tm = cputime(subprocesses=True)
            mucand = subsetsumdecrypt(A, v, a, x)[_sage_const_1 ]
            tottime += float(cputime(tm))
            if mu == mucand:
                succnow += _sage_const_1 
        succ += succnow
        print("Key pair %d complete. Success rate: %d/%d." % (npair, succnow, trials))
    print("Successful recoveries: %d/%d (%f)." % (succ, trials * pairs, RR(_sage_const_100  * succ / trials / pairs)))
    print("Average time: %f seconds." % (tottime / trials / pairs))

# Run the test
testsubsetsumdecrypt(_sage_const_1 , _sage_const_1 )

